

from .utils import utils
from Requester import Requester
from DataHandlers import dlist_dict,list_dlist, setNum, dateFormat, get_previous_day 
from datetime import datetime

class DHANHandler:

    def __init__(self, access_token:str, client_id:str='', dbName:str='dhan_db.db', pathway:str='.', localRunner:bool=True)->None:

        self.client_id, self.access_token = client_id,access_token
        self.dbConn = utils.connect_db('dhan.db', './app/database')
        self.request = Requester()
        self.header = {"access-token": self.access_token,"Content-Type": "application/json","Accept": "application/json"}
        
        if localRunner: self.local_runner()

    def getOrdersById(self, orderId:str, fetchNew:bool=False):
        """
            getOrdersById()
            ===============
            Users can retrieve the details and status of an order from the orderbook placed during the day.
        """
        response = self.getOrdersList(orderId=orderId)
        if fetchNew:
            response = self.requester(f'https://api.dhan.co/orders/{orderId}')
        return response

    def getOrdersList(self, orderId:str='', fetchNew:bool=False):
        """
            getOrdersList()
            ------------
            This API lets you retrieve an array of all orders requested in a day with their last updated status.
            
        """
        
        table = 'ordersList'
        query = []
        if orderId!='': query.append(f"orderId = '{orderId}'")
        response = self.dbConn.fetch(table, query=query)
        if len(response)==0 or fetchNew==True: 
            response = self.requester('https://api.dhan.co/orders')
            response = [{**res, 'afterMarketOrder': ('true' if res['afterMarketOrder'] else 'false')} for res in response]
            self.dbConn.json_insert(table, response, ifExist='orderId')
        response = [i for i in response if i['orderId'] == orderId][0] if orderId!='' else response
        return response
    
    def modifyPendingOrders(self, orderId:str, quantity:int, price:float, disclosedQuantity:int, triggerPrice:float=0.0, validity:str='DAY', orderType:str="LIMIT", legName:str='ENTRY_LEG')->dict:
        """
            modifyPendingOrders()
            =====================

            Using this API one can modify pending order in orderbook. The variables that can be modified are price, quantity, order type & validity.

            Args:
            ----
                - `orderId` (str) : Order specific identification generated by Dhan.
                - `quantity` (int) : Number of shares for the order.
                - `price` (float) : Price at which the order is requested to execute.
                - `disclosedQuantity` (int): Number shares visible in the market depth.
                - `triggerPrice` (float): Price at which the order is triggered.
                - `validity` (str): 
                    Allowed values are -
                    - `DAY`: Valid till end of day.
                    - `IOC`: Immediate or Cancel.
                    - `GTC`: ...
                    - `GTD`: ...
                - `orderType` (str): 
                    Allowed values are-
                    - `LIMIT`: For Limit Order types
                    - `MARKET`: For market Order types
                    - `STOP_LOSS`: For Stop Loss Limit orders
                    - `STOP_LOSS_MARKET`: For Stop Loss Market orders
                - `legName` (str) : Allowed values:
                    - `ENTRY_LEG` : ...
                    - `STOP_LOSS_LEG` : ...
                    - `TARGET_LEG` : ...
                    - `NA` : ...

            Return:
            -------
                - dict: Return data n a dict format.
                    - `orderId` (str): Order specific identification generated by Dhan
                    - `orderStatus` (str): 
                        - `TRANSIT`: Did not reach the exchange server.
                        - `PENDING`: Reached at exchange end, awaiting execution.
                        - `REJECTED`: Rejected at exchange/broker's end.
                        - `CANCELLED`: Cancelled by user.
                        - `TRADED`: Executed.
                        - `EXPIRED`: Validity of order is expired.
        """

        payload = {"dhanClientId": self.client_id,"orderId": orderId,"orderType": orderType,"legName": legName,
            "quantity": quantity,"price": price,"disclosedQuantity": disclosedQuantity,"triggerPrice": float(price + triggerPrice),"validity": validity}
        
        return self.requester("https://api.dhan.co/orders/123", method='put', json=payload)

    def cancelOrders(self, orderId:str)->dict:
        """
            cancelOrders()
            ==============
            Users can cancel a pending order in the orderbook using the order id of an order.

            Args:
            -----
            - `orderId` (str): Order specific identification generated by Dhan.

            Return:
            -------
            - dict: Return data n a dict format.
                - `orderId` (str): Order specific identification generated by Dhan
                - `orderStatus` (str): 
                    - `TRANSIT`: Did not reach the exchange server.
                    - `PENDING`: Reached at exchange end, awaiting execution.
                    - `REJECTED`: Rejected at exchange/broker's end.
                    - `CANCELLED`: Cancelled by user.
                    - `TRADED`: Executed.
                    - `EXPIRED`: Validity of order is expired.
        """
        return self.requester(f'https://api.dhan.co/orders/{orderId}', 'delete')

    def placeOrder(self, correlationId:str, transactionType:str, exchangeSegment:str, validity:str, tradingSymbol:str, securityId:str, quantity:str, disclosedQuantity:str, price:float, triggerPrice:float, boProfitValue:float, boStopLossValue:float, drvExpiryDate:str, drvOptionType:str, drvStrikePrice:float, productType:str='INTRADAY', orderType:str='MARKET', amoTime:str='OPEN', afterMarketOrder:bool=True):
        """
            placeOrder()
            ============
            The order request API lets you place new orders.
            
            Args:
            -----
                - `correlationId` (str|optional):The user/partner generated id for tracking back. The range of charecters permitted is 0 to 25.
                - `transactionType` (str): Signifies the type of transaction wether it's BUY or SELL.
                - `exchangeSegment` (str): 
                    - `NSE_EQ`: The exchange is NSE for segment Equity Cash.
                    - `NSE_FNO`: The exchange is NSE for segment Futures & Options.
                    - `NSE_CURRENCY`: The exchange is NSE for segment Currency.
                    - `BSE_EQ`: The exchange is BSE for segment Equity Cash.
                    - `BSE_FNO`: The exchange is BSE for segment Futures & Options.
                    - `BSE_CURRENCY`: The exchange is BSE for segment Currency.
                    - `MCX_COMM`: The exchange is MCX for segment Commodity.
                - `tradingSymbol` (str):Exchange standard trading symbol.
                - `securityId` (str): Exchange standard identification for each scrip.
                - `quantity` (integer): Number of shares for the order. It's value should be greater than 0.
                - `disclosedQuantity` (integer): Number shares visible in the market depth.
                - `price` (float): Price at which the order is requested to execute.
                - `triggerPrice` (float): Price at which the order is triggered.
                - `boProfitValue` (float): Bracket order Target price.
                - `boStopLossValue` (float): Bracket Order/Cover Order Stop Loss Price.
                - `drvExpiryDate` (str):For F&O, expiry date of contract.
                - `drvOptionType` (str): For Options, type CALL or PUT.
                - `drvStrikePrice` (float): For Options, Strike Price
                - `productType` (str):Default is `INTRADAY`. The values accepted are
                    - `CNC`: Cash & Carry for equity deliveries.
                    - `INTRADAY`: Intraday for Equity, Futures & Options.
                    - `MARGIN`: Carry Forward in Futures & Options.
                    - `CO`: Cover Order; entry and stop loss.
                    - `BO`: Bracket Order; entry, stop loss & target price.
                    - `MTF`: Margin Traded Fund.
                    CO & BO product types will be valid only for Intraday.
                - `orderType` (str): Default is `MARKET`. The values accepted are
                    - `LIMIT`: For Limit Order types.
                    - `MARKET`: For market Order types.
                    - `STOP_LOSS`: For Stop Loss Limit orders.
                    - `STOP_LOSS_MARKET`: For Stop Loss Market orders.
                - `validity` (str): Allowed values are 
                    - `DAY`: Valid till end of day.
                    - `IOC`: Immediate or Cancel.
                    - `GTC`: ...
                    - `GTD`: ...- `amoTime` (str): Flag to inform after what time AMO is pumped. Default is `OPEN`. Allowed values:
                    - `OPEN`: When market opens.
                    - `OPEN_30`: 30 minutes after market opens.
                    - `OPEN_60`: 60 minutes after market opens.
                - `afterMarketOrder` (bool): Flag to inform that the order placed is After Market Order. Default is True.

        """
        
        payload = {"dhanClientId": self.client_id,"correlationId": correlationId,"transactionType": transactionType,"exchangeSegment": exchangeSegment,"productType": productType,"orderType": orderType,"validity": validity,"tradingSymbol": tradingSymbol,"securityId": securityId,"quantity": quantity,"disclosedQuantity": disclosedQuantity,"price": price,"triggerPrice": triggerPrice,"afterMarketOrder": afterMarketOrder,"amoTime": amoTime,"boProfitValue": boProfitValue,"boStopLossValue": boStopLossValue,"drvExpiryDate": drvExpiryDate,"drvOptionType": drvOptionType,"drvStrikePrice": drvStrikePrice}

        response = self.requester('https://api.dhan.co/orders', 'post', json=payload)
        return response
    
    def orderSlicing(self, correlationId:str,transactionType:str,exchangeSegment:str,productType:str,orderType:str,validity:str,tradingSymbol:str,securityId:str,quantity:str,disclosedQuantity:str,price:str,triggerPrice:str,afterMarketOrder:str,amoTime:str,boProfitValue:str,boStopLossValue:str,drvExpiryDate:str,drvOptionType:str,drvStrikePrice:str):
        """
            orderSlicing()
            --------------
            The order request API lets you place new slice orders.

            Args:
            - correlationId (str):
            - transactionType (str):
            - exchangeSegment (str):
            - productType (str):
            - orderType (str):
            - validity (str):
            - tradingSymbol (str):
            - securityId (str):
            - quantity (str):
            - disclosedQuantity (str):
            - price (str):
            - triggerPrice (str):
            - afterMarketOrder (str):
            - amoTime (str):
            - boProfitValue (str):
            - boStopLossValue (str):
            - drvExpiryDate (str):
            - drvOptionType (str):
            - drvStrikePrice (str):
        """

        payload = {"dhanClientId": self.client_id,
            "correlationId":correlationId,
            "transactionType":transactionType,
            "exchangeSegment":exchangeSegment,
            "productType":productType,
            "orderType":orderType,
            "validity":validity,
            "tradingSymbol":tradingSymbol,
            "securityId":securityId,
            "quantity":quantity,
            "disclosedQuantity":disclosedQuantity,
            "price":price,
            "triggerPrice":triggerPrice,
            "afterMarketOrder":afterMarketOrder,
            "amoTime":amoTime,
            "boProfitValue":boProfitValue,
            "boStopLossValue":boStopLossValue,
            "drvExpiryDate":drvExpiryDate,
            "drvOptionType":drvOptionType,
            "drvStrikePrice":drvStrikePrice,
        }
        
        return self.requester('https://api.dhan.co/orders/slicing','post', json=payload)

    def getCorrelationId(self, correlation_id:str):
        """
            getCorrelationId()
            ------------------
            In case the user has missed order id due to unforeseen reason, this API retrieves the order status using a field called correlation id, Provided by API consumer during order placement.
        """
        response = self.requester(f'https://api.dhan.co/orders/external/{correlation_id}')
        return response

    def convert_position(self, fromProductType:str='', exchangeSegment:str='', positionType:str='', securityId:str='', tradingSymbol:str='', convertQty:int=0, toProductType:str=''):
        """
            convert_position()
            ------------------
            Users can convert their open position from intraday to delivery or delivery to intraday.
        """
        payload = {"dhanClientId": self.client_id,
            "fromProductType":fromProductType,
            "exchangeSegment":exchangeSegment,
            "positionType":positionType,
            "securityId":securityId,
            "tradingSymbol":tradingSymbol,
            "convertQty":convertQty,
            "toProductType":toProductType
        }
        
        response = self.requester('https://api.dhan.co/positions/convert', 'post', json=payload, stat_code=202)
        return response

    def current_positon(self):
        """
            current_positon()
            -----------------
            Users can retrieve a list of all open positions for the day. This includes all F&O carryforward positions as well.
        
        """
        response =  self.requester("https://api.dhan.co/positions")
        return response
 
    def current_holdings(self, exchange:str='', tradingSymbol:str='', securityId:str='', isin:str='', dt_from:str='', dt_format:str='%Y-%m-%d', fetchNew:bool=False)->list:
        """
            current_holdings()
            ------------------

            Users can retrieve all holdings bought/sold in previous trading sessions. All T1 and delivered quantities can be fetched.
        """
        if fetchNew:
            response = self.requester('https://api.dhan.co/holdings')
        else:
            table = 'holdings'
            query = []
            if exchange!='': query.append(f"exchange='{exchange}'")
            if tradingSymbol!='': query.append(f"tradingSymbol='{tradingSymbol}'")
            if securityId!='': query.append(f"securityId='{securityId}'")
            if isin!='': query.append(f"isin='{isin}'")
            
            if dt_from !='':
                dt = dateFormat(dt_from, dt_format, '%Y-%m-%d')
                query.append(f"DATE(time_stamp)=DATE('{dt}')")

            response = self.dbConn.fetch(table, query=query)
            if len(response) == 0:
                response = self.current_holdings(fetchNew=True)
                self.dbConn.json_insert(table, response)

        return response
 
    def intraday_chart(self, securityId:str, exchangeSegment:str, instrument:str):
        """
            intraday_chart()
            ----------------
            Retrieve OHLC & Volume of 1 minute candle for desired instrument for current day. This data available for all segments including futures & options.
        """
        table = 'api_script'
        if securityId not in self.dbConn.fetch_unique(table, 'SEM_SMST_SECURITY_ID'): raise ValueError('The cvalue passed in the securityId is not valid')
        if exchangeSegment not in self.dbConn.fetch_unique(table, ''): raise ValueError('The cvalue passed in the exchangeSegment is not valid')
        if instrument not in self.dbConn.fetch_unique(table, ''): raise ValueError('The cvalue passed in the instrument is not valid')

        payload = {"securityId": securityId,"exchangeSegment": exchangeSegment,"instrument": instrument}
        response = self.requester('https://api.dhan.co/charts/intraday', 'post', json=payload)
        return response

    def histiorical_ohlc(self, securityId:str, exchangeSegment:str, instrument:str, expiryCode, dt_from:str, dt_to:str, dt_format:str=''):
        """
            histiorical_ohlc()
            ------------------
            Retrieve OHLC & Volume of daily candle for desired instrument. The data for any scrip is available back upto the date of its inception.
        """
        dt_from = dt_from if dt_format=='%Y-%m-%d' else dateFormat(dt_format, dt_format, '%Y-%m-%d')
        dt_to = dt_to if dt_format=='%Y-%m-%d' else dateFormat(dt_to, dt_format, '%Y-%m-%d')
        payload = {"symbol": securityId,"exchangeSegment": exchangeSegment,"instrument": instrument,"expiryCode": expiryCode,"fromDate": dt_from,"toDate": dt_to}
        response = self.requester('https://api.dhan.co/charts/historical', 'post', json=payload)
        return response
    
    def edisBulkForm(self, isin:list,exchange:str, segment:str):
        """
            edisBulkForm()
            --------------
            Retrieve escaped html form of CDSL and enter T-PIN to mark the stock for EDIS approval. Partner has to render this form at their end to unescape.
        """
        payload = {"isin": isin,"exchange": exchange,"segment": segment}
        response = self.requester('https://api.dhan.co/edisbulk/form', 'post', json=payload)

        return response
   
    def edisForm(self, isin:str, qty:int, exchange:str, segment:str,):
        """
            edisForm()
            ----------
            Retrieve escaped html form of CDSL and enter T-PIN to mark the stock for EDIS approval. Partner has to render this form at their end to unescape.
        """
        payload = {"isin": isin,"qty": qty,"exchange": exchange,"segment": segment,"bulk": True}
        response = self.requester('https://api.dhan.co/edis/form', 'post', json=payload)

        return response
   
    def edisGeneratePin(self):
        """
            edisGeneratePin()
            -----------------
            Get T-PIn on customer's registered mobile number using this API.
        """ 

        response =  self.requester('https://api.dhan.co/edis/tpin', stat_code=202)
        return response
   
    def edisCheckAuthorizedQuantity(self, isin:str):
        """
            edisCheckAuthorizedQuantity()
            -----------------------------
            You can check the status of stock whether it is approved and marked for sell action. User have to enter ISIN of the stock. An International Securities Identification Number (ISIN) is a 12-digit alphanumeric code that uniquely identifies a specific security. You can get ISIN of portfolio stocks, in response of holdings API. Or use ALL as a special case to query all holdings' edis auth status.        
        """
        
        response =  self.requester(f'https://api.dhan.co/edis/inquire/{isin}')
        return response

    def getAllTrades(self, fetchNew:bool=False)->list:
        """
            getAllTrades()
            --------------
            This API lets you retrieve an array of all trades executed in a day.
        """
        query = ''
        response = self.dbConn.fetch('trades', query=query)
        if fetchNew or len(response) == 0:
            response =  self.requester('https://api.dhan.co/trades')
            self.dbConn.json_insert('trades', response, ifExist='orderId')
        return response
    
    def tradesByOrder(self, orderId:str):
        """
            tradesByOrder()
            ---------------

            Users can retrieve the trade details using an order id. Often during partial trades or Bracket/ Cover Orders, traders get confused in reading trade from tradebook. The response of this API will include all the trades generated for a particular order id.
        """ 

        response =  self.requester(f'https://api.dhan.co/trades/{orderId}')
        return response
    
    def getTradeHistory(self, dt_from:str, dt_to:str, page_number:int, dt_format:str='%Y-%m-%d'):
        """
            getTradeHistory()
            -----------------

            Users can retrieve the trade history Often during partial trades or Bracket/ Cover Orders, traders get confused in reading trade from tradebook. The response of this API will include all the trades generated for a particular order id.
        """
        dt_from = dt_from if dt_format=='%Y-%m-%d' else dateFormat(dt_format, dt_format, '%Y-%m-%d')
        dt_to = dt_to if dt_format=='%Y-%m-%d' else dateFormat(dt_to, dt_format, '%Y-%m-%d')
        response =  self.requester(f'https://api.dhan.co/tradeHistory/{dt_from}/{dt_to}/{page_number}')
        return response
    
    def getLedger(self, dt_from:str='', dt_to:str='', dt_format:str='%Y-%m-%d', fetchNew:bool=False)->dict:
        """ 
            getLedger()
            -----------
            Get Trading Account Ledger with all Credit and Debit transaction details.
        """
        dt_to = datetime.now().strftime('%Y-%m-%d') if dt_to!='' else dateFormat(dt_to, dt_format, '%Y-%m-%d')
        dt_from = get_previous_day(dt_to, '%Y-%m-%d') if dt_from!='' else dateFormat(dt_from, dt_format, '%Y-%m-%d')
        response = self.dbConn.fetch('ledger',query=f"DATE(time_stamp) BETWEEN DATE('{dt_from}') AND DATE('{dt_to}')")
        if fetchNew or len(response) == 0:
            response = self.requester("https://api.dhan.co/ledger")
            self.dbConn.json_insert('ledger', response, ifExist='voucherdate,vouchernumber')
        self._updateLog('ledger', f'{dt_from} - {dt_to} - {dt_format}', 1)
        return response

    def getFundLimit(self, dt_of:str='', dt_format:str='%Y-%m-%d', getAll:bool=True, fetchNew:bool=False)->dict:
        """
            getFundLimit()
            --------------
            Get all information of your trading account like balance, margin utilised, collateral, etc.
        """
        catg = 'db'
        dt_of = datetime.now().strftime('%Y-%m-%d') if dt_of =='' else dateFormat(dt_of, dt_format, '%Y-%m-%d')
        desc = 'id' if getAll==False else ''
        response = self.dbConn.fetch('funds', query=f"DATE(time_stamp)='{dt_of}'", fetchAll=getAll, desc=desc)
        if fetchNew or len(response) == 0:
            response = self.requester("https://api.dhan.co/fundlimit")
            if response is not False and response is not None: 
                self.dbConn.json_insert('funds', response)
                self.client_id = response['dhanClientId'] if self.client_id!=self.client_id else self.client_id
                catg = 'net'
        ret = 1 if len(response) == 0 else 0
        self._updateLogs('getFundLimit', catg, ret)
        return response

    # others sections
 
    def getDocs(self, createFile:str=''):
        """
        """
        response = self.requester('https://api.dhan.co/v3/api-docs')
        if createFile!='':
            from FileHandler import write
            write(f'{createFile}.json', response, '\n', True)
        return response

    def fetchUrls(self, name:str='', fetchNew:bool=False):
        """
            fetchUrls()
            -----------
        """
        
        table = 'urls'
        query = f"operationId='{name}' OR summary='{name}'" if name!='' else ''
        data = self.dbConn.fetch(table, query=query)
        ret = 'db'
        if len(data) == 0 or fetchNew:
            docs = self.getDocs()
            serverUrl = docs['servers'][0]['url']
            paths = docs['paths'] 
            data = [{'url': serverUrl + ke, 'method': method, 'summary': paths[ke][method]['summary'], 'description': paths[ke][method]['description'], 'operationId': paths[ke][method]['operationId'], 'tags': ','.join(paths[ke][method]['tags'])} for ke in list(paths.keys()) for method in paths[ke].keys()]
            self.dbConn.json_insert(table, data, ifExist='url')
            ret = 'net'
        self._updateLogs(table, ret ,1)    
        return data
        
    def getApiScript(self, securityId:int=0,fetchNew:bool=False)->dict:
        """
            getApiScript()
            --------------
            This method downoads the  API script of the user's app and returns it as a dictionary.

            Parameters:
                - `securityId`(int): takes the unique security id issued by the exchange.

        """
        table = 'api_script'
        ret = 'db'
        query = f"SEM_SMST_SECURITY_ID='{securityId}'" if securityId!=0 else ''
        data = self.dbConn.fetch(table, query=query)
        if len(data) == 0 or fetchNew:
            data = self.requester('https://images.dhan.co/api-data/api-scrip-master.csv')
            if data is not None and data is not False:
                data = [d.split(',') for d in data.split('\n')] 
                data = setNum(dlist_dict(list_dlist(data[1:], data[0])))
                self.dbConn.json_insert(table, data, ifExist='SEM_SMST_SECURITY_ID')
                ret = 'net'
        data = [i for i in data if i['SEM_SMST_SECURITY_ID'] == securityId][0] if securityId!=0 else data

        self._updateLog(table, f'{ret} {securityId}', 1)
        return data
    
    def requester(self, url:str, method:str='get', params:dict={}, refer:str='', header:dict={}, json:dict={}, timeout:int=60, catg:int=1, decode:bool=True, stat_code:int=200):
        """
            A method that returns an object of Requester Class for making HTTP requests.
        
            Parameters:
            - url (str): The URL to which request will be sent.
            - method (str): The metho that will be used to send the request.  Default value is GET.
            - headers (dict): Headers for the request. If no argument provided then default headers are used.
            - params (dict): The PARAMS that are to be send during request.
        """

        header = self.header if header=={} else {**self.header, **header}
        ret = None
        if catg==1:
            ret = self.request.request(url, method=method,  ref=refer, params=params, header=header, json=json, timeout=timeout)
        elif catg==2:
            if self.sessions==None:
                ret, self.sessions = self.request.requestSessions(url, method=method, ref=refer, params=params, header=header, timeout=timeout, pre_request='https://www.nseindia.com')
            else:
                ret, self.sessions = self.request.requestSessions(url, method=method,  ref=refer, header=header, params=params, timeout=timeout, sessions=self.sessions)
        stat = ret.status_code
        if ret!=None and stat==stat_code:
            res = 1
            if decode:
                try: 
                    ret = ret.json()
                except:
                    try:
                        ret = ret.text
                    except:
                        ret = None
        else:
            res = 0 
            ret = None

        self._updateLogs('requester', f'{url}-{stat}', res)
        return ret
  
    def local_runner(self, catg:str='')->None:
        """
            local_runner()
            --------------
            Runner function to be used by other functions.

            Parameter:
                - catg (str): Takes the func key the is to be runned.
        """
        self.check_db()
        runner = {
            'getApiScript':{'func':self.getApiScript, 'params': {'fetchNew':True}},
            'fetchUrls': {'func':self.fetchUrls,'params':{}},
            'getFundLimit' : {'func': self.getFundLimit, 'param':{'getAll':False, 'fetchNew':True}},
            'getOrdersList': {'func': self.getOrdersList, 'param':{}},
            'getLedger': {'func':self.getLedger, 'param':{}},
        }
        if catg=='':
            for k,v in runner.items():
                v['func'](**v['params']) if v['params']!={} else v['func']()
                print(f"Done with '{k}'")
        elif catg!='' and catg in runner.keys():
            v['func'](**v['params']) if v['params']!={} else v['func']()
        else:
            raise ValueError('The value passed is invalid.')

    def check_db(self)->None:
        """
            check_db()
            ----------
            This method is to check the database and make the create tables so that it can run properly.
            Tabes that this method creates are:
            - api_script: Stores the asset lists, Codes & other necessary info. 
            - urls: To store the urls and other values.
            - holdings: Stores the assets in the holding. 
            - orders: Stores the orders made.  
        """

        db_tables = self.dbConn.getTb()
        tables = [
            {'table_name':'api_script', 'column_names':['id INTEGER PRIMARY KEY','SEM_EXM_EXCH_ID TEXT','SEM_SEGMENT TEXT','SEM_SMST_SECURITY_ID INTEGER','SEM_INSTRUMENT_NAME TEXT','SEM_EXPIRY_CODE REAL','SEM_TRADING_SYMBOL TEXT','SEM_LOT_UNITS REAL','SEM_CUSTOM_SYMBOL TEXT','SEM_EXPIRY_DATE TEXT','SEM_STRIKE_PRICE REAL','SEM_OPTION_TYPE TEXT','SEM_TICK_SIZE REAL','SEM_EXPIRY_FLAG TEXT','SEM_EXCH_INSTRUMENT_TYPE TEXT','SEM_SERIES TEXT','SM_SYMBOL_NAME TEXT'], 'indexes': ''},
            {'table_name': 'urls', 'column_names': ['id INTEGER PRIMARY KEY','url TEXT', 'method TEXT', 'summary TEXT', 'description TEXT', 'operationId TEXT', 'tags TEXT'],  'indexes': 'url,method,operationId,tags'},
            {'table_name': 'holdings', 'column_names':["id INTEGER PRIMARY KEY","exchange TEXT","tradingSymbol TEXT","securityId TEXT","isin TEXT","totalQty INTEGER","dpQty INTEGER","t1Qty INTEGER","availableQty INTEGER","collateralQty INTEGER","avgCostPrice REAL", "time_stamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP"], 'indexes': 'exchange,tradingSymbol,isin,securityId,time_stamp'},
            {'table_name': 'orders', 'column_names':['id INTEGER PRIMARY KEY', "dhanClientId TEXT", "orderId TEXT", "exchangeOrderId TEXT", "correlationId TEXT", "orderStatus TEXT", "transactionType TEXT", "exchangeSegment TEXT", "productType TEXT", "orderType TEXT", "validity TEXT", "tradingSymbol TEXT", "securityId TEXT", "quantity INEGER", "disclosedQuantity INTEGER", "price REAL", "triggerPrice REAL", "afterMarketOrder TEXT", "boProfitValue REAL", "boStopLossValue REAL", "legName TEXT", "createTime TEXT", "updateTime TEXT", "exchangeTime TEXT", "drvExpiryDate TEXT", "drvOptionType TEXT", "drvStrikePrice REAL", "omsErrorCode TEXT", "omsErrorDescription TEXT", "filled_qty INTEGER", "algoId TEXT"], 'indexes': 'orderId,exchangeOrderId,createTime'},
            {'table_name': 'funds', 'column_names':['id INTEGER PRIMARY KEY', 'dhanClientId TEXT', 'availabelBalance REAl', 'sodLimit REAl', 'collateralAmount REAl', 'receiveableAmount REAl', 'utilizedAmount REAl', 'blockedPayoutAmount REAl', 'withdrawableBalance REAl', "time_stamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP"], 'indexes': 'time_stamp'},
            {'table_name': 'trades', 'column_names':['id INTEGER PRIMARY KEY',"dhanClientId TEXT","orderId TEXT","exchangeOrderId TEXT","exchangeTradeId TEXT","transactionType TEXT","exchangeSegment TEXT","productType TEXT","orderType TEXT","tradingSymbol TEXT","securityId TEXT","customSymbol TEXT","tradedPrice REAL","tradedQuantity INTEGER","updateTime TEXT","createTime TEXT","drvExpiryDate TEXT","exchangeTime TEXT","drvStrikePrice REAL","drvOptionType TEXT","time_stamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP"], 'indexes': 'orderId,exchangeOrderId,exchangeTradeId,transactionType,exchangeSegment'},
            {'table_name': 'logbook', 'column_names':['id INTEGER PRIMARY KEY','name TEXT', 'value TEXT', 'result INTEGER', 'time_stamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP'], 'indexes': 'name,result,time_stamp'},
            {'table_name': 'ledger', 'column_names':['id INTEGER PRIMARY KEY', "dhanClientId TEXT","narration TEXT","voucherdate TEXT","exchange TEXT","voucherdesc TEXT","vouchernumber TEXT","debit TEXT","credit TEXT","runbal TEXT",'time_stamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP'], 'indexes': ''},
            {'table_name': '', 'column_names':[], 'indexes': ''},
            {'table_name': '', 'column_names':[], 'indexes': ''},
            ]
        for i in tables:
            if i['table_name']!='' and i['table_name'] not in db_tables:
                self.dbConn.createTb(i['table_name'], i['column_names'], indexCol=i['indexes'])
                print(i['table_name'], ' Created..')

    def _updateLogs(self, name, value:str, success:int) -> bool:
        """
            updateLogs
            ----------
            This method when fired will log the events that have occured or tasks executed by the class.
        """
        t = self.dbConn.insert('logbook', ['name', 'value', 'result'], [name, value, success])
        return True if t else False

    def exportDate(self, table_name:str=''):
        """
            exportDate()
            ------------
            
            This method exports the data of the database into a file. 
        """
        self.dbConn.export_data(tableName=table_name)
